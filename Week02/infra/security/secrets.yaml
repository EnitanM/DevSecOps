## This is an example and not being used to avoid committing real secrets when not properly configured.
## Secrets have been created using kubectl and shown in the namespace on the kubernetes dashboard.
apiVersion: v1
kind: Secret
metadata:
  name: project-secrets
  namespace: namespace
type: Opaque
data:
  DB_USER: *******   # base64 of 'flaskuser'
  DB_PASS: *******   # base64 of 'flaskpass'
  
Note: Always encode secret values using Base64 before committing, and never include plaintext credentials in GitHub.

---------

How to Verify Secrets in Application

Add environment variables in your Deployment manifest or Helm chart:
env:
  - name: DB_USER
    valueFrom:
      secretKeyRef:
        name: flask-secrets
        key: DB_USER
  - name: DB_PASS
    valueFrom:
      secretKeyRef:
        name: flask-secrets
        key: DB_PASS
Then confirm they are mounted inside the pod: kubectl exec -it <pod-name> -- env | grep DB_